<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<script src="./pan-zoom.js"></script>
</head>
<style>
	body {
		margin: 0;
	}

	#grid {
		width: 100%;
		height: 100vh;
	}

	.grid-container {
		width: 100vw;
		height: 100vh;
		overflow: hidden;
	}

	.grid-container svg path {
		vector-effect: non-scaling-stroke;
		width: 100%;
		height: 100%;
		object-fit: contain;
	}
</style>
<body style="background: black; width: 100%; height: 100%;">
	<div class="grid-container">
		<svg id="gridsvg" width="1920" height="1080" xmlns="http://www.w3.org/2000/svg">
			<defs>
			<pattern id="grid" width="80" height="80" patternUnits="userSpaceOnUse">
				<path d="M 80 0 L 0 0 0 80" fill="none" stroke="gray" stroke-width="1"/>
			</pattern>
			</defs>
			<rect width="100%" height="100%" fill="url(#grid)" />
		  </svg>
	</div>

	<script>
		document.addEventListener('DOMContentLoaded', () => {
			const zoom = svgPanZoom("#gridsvg", {
				zoomEnabled: true,
				fit: true,
				center: true,
			});
		});
	</script>
	<script>
		document.addEventListener('DOMContentLoaded', () => {
			return;
			const canvas = document.querySelector('#grid');
			const context = canvas.getContext('2d');

			let CANVAS_BASE_WIDTH = canvas.width;
			let CANVAS_BASE_HEIGHT = canvas.height;

			const middleLineWidth = CANVAS_BASE_WIDTH / 2;
			const middleLineHeight = CANVAS_BASE_HEIGHT / 2;

			const STEP = 200;

			const fillLimitsColumns = (x, step) => {
				lines = [];
				if (step > 0) {
					while(x + step <= CANVAS_BASE_WIDTH) {
						lines.push([[x + step, 0], [x+step, CANVAS_BASE_WIDTH]]);
						x+=step;
					}
				} else {
					while(x + step >= 0) {
						lines.push([[x + step, 0], [x+step, CANVAS_BASE_WIDTH]]);
						x+=step;
					}
				}
				return lines;
			}

			const fillLimitsRows = (y, step) => {
				lines = [];
				if (step > 0) {
					while(y + step <= CANVAS_BASE_HEIGHT) {
						lines.push([[0, y + step], [CANVAS_BASE_WIDTH, y + step]]);
						y+=step;
					}
				} else {
					while(y + step >= 0) {
						lines.push([[0, y + step], [CANVAS_BASE_WIDTH, y + step]]);
						y+=step;
					}
				}
				return lines;
			}

			let fullSize = [
				[[middleLineWidth, 0], [middleLineWidth, CANVAS_BASE_WIDTH]],
				[[0, middleLineHeight], [CANVAS_BASE_WIDTH, middleLineHeight]],
				...fillLimitsColumns(middleLineWidth, STEP),
				...fillLimitsColumns(middleLineWidth, -STEP),
				...fillLimitsRows(middleLineHeight, STEP),
				...fillLimitsRows(middleLineHeight, -STEP),
			];

			const step = 100;

			const calculateBaseData = () => {
				const middleLineWidth = CANVAS_BASE_WIDTH / 2;
				const middleLineHeight = CANVAS_BASE_HEIGHT / 2;

				const midleVerticalLine = [[middleLineWidth, 0], [middleLineWidth, CANVAS_BASE_WIDTH]];
				const midleHorizontalLine = [[0, middleLineHeight], [CANVAS_BASE_WIDTH, middleLineHeight]];

				return {
					middle_vertical: midleVerticalLine,
					middle_horizontal: midleHorizontalLine,
				}
			}

			const baseMiddle = calculateBaseData();

			const anim = () => {
				context.strokeStyle = '#ff0';
				context.lineWidth = 2;

				context.beginPath();
				Object.values(fullSize).forEach((line) => {
					context.moveTo(line[0][0], line[0][1]);
					context.lineTo(line[1][0], line[1][1]);
				});

				context.stroke();
				requestAnimationFrame(anim);
			}

			requestAnimationFrame(anim);

			window.addEventListener('resize', () => {
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
			});
		});
	</script>

	<script>
		document.addEventListener("DOMContentLoaded", () => {
			return;
			const container = document.querySelector('.grid-container');
			const createBox = (n) => {
				const nSquares = n*n;
				const windowWidth = window.innerWidth;
				const windowHeight = window.innerHeight;

				const squareSide = Math.sqrt(windowWidth * windowHeight / nSquares);

				return {
					side: squareSide,
					rows: Math.ceil(windowHeight / squareSide),
					columns: Math.ceil(windowHeight / squareSide),
				}
				return squareSide;
			};

			const createSquare = (dimensions) => {
				console.log(dimensions);
				const rows = [];

				for(let row = 0; row < dimensions.rows; row++) {
					const rowElement = document.createElement("div");
					rowElement.classList.add('row');
					rowElement.style.height = dimensions.side + 'px';

					const cells = [];

					for (let column = 0; column < dimensions.columns; column++) {
						const cellElement = document.createElement('div');
						cellElement.classList.add('cell');
						cellElement.style.width = dimensions.side + 'px';
						cellElement.style.height = dimensions.side + 'px';
						cells.push(cellElement);
					}

					cells.forEach((cell) => {
						rowElement.appendChild(cell);
					});

					rows.push(rowElement);
				}

				rows.forEach((row) => {
					container.append(row);
				});
			}


			window.addEventListener('resize', () => {
				container.innerHTML = ""
				createSquare(createBox(2));
			});
		});
	</script>
</body>
</html>